高可用可伸缩微服务架构
1.1 什么是架构 1
1.2 几个相关概念 3
1.3 从软件的生命周期看架构设计 7
1.4 架构的形式与特点 9
1.5 架构的目标与方法 13
1.6 架构的不同风格 18
第2章 微服务领域驱动设计 30
2.1 领域驱动设计 31
2.1.1 领域驱动设计概览 31
2.1.2 问题域与解决方案域 34
2.1.3 限界上下文 35
2.1.4 上下文映射 40
2.1.5 领域架构 43
2.2 微服务的设计 48
2.2.1 限界上下文的边界 48
2.2.2 限界上下文即微服务 51
2.2.3 识别限界上下文 53
2.2.4 微服务之间的协作 59
2.3 小结 63
第3章 Apache Dubbo框架的原理与实现 64
3.1 Dubbo框架的选型与使用 64
3.1.1 Dubbo框架的选型 64
3.1.2 Dubbo框架的使用 65
3.2 Dubbo框架的原理分析 70
3.2.1 总体架构分析 70
3.2.2 Dubbo Bean的加载 73
3.2.3 Dubbo Extension机制 77
3.2.4 Dubbo消费端 91
3.2.5 Dubbo服务端 126
3.2.6 Dubbo的通信机制 144
3.3 基于Dubbo的自动化Mock系统 165
3.3.1 Mock模拟系统的产生 166
3.3.2 Dubbo Mock的使用 167
3.3.3 Dubbo Mock的原理解析 168
3.3.4 自动化Mock系统的实现 170
第4章 Spring Boot/Spring Cloud实践 177
4.1 Spring Boot原理剖析 178
4.1.1 Spring Boot Quick Start 178
4.1.2 Spring Boot之SpringApplication 180
4.1.3 spring-boot-loaded模块分析 186
4.1.4 spring-boot-autoconfigure模块分析 190
4.1.5 Spring Boot Conditional注解分析 195
4.2 Dubbo Spring Boot Starter 198
4.2.1 Dubbo Spring Boot Starter简介 198
4.2.2 Dubbo Initializr及sample 198
4.2.3 dubbo-spring-boot-autoconfigure模块 201
4.2.4 dubbo-spring-boot-actuator模块 204
4.3 Spring Cloud栈 211
4.3.1 为什么微服务架构需要Spring Cloud 212
4.3.2 Spring Cloud技术栈总览 214
4.3.3 spring-cloud-scaffold基础库集合 215
4.4 基于Maven Archetype的脚手架 239
4.4.1 Maven Archetype 239
4.4.2 脚手架的搭建 240
4.4.3 生成脚手架 247
第5章 微服务稳定性保证的常用手段 250
5.1 微服务的稳定性 250
5.2 高可用 250
5.2.1 限流原理与实现 250
5.2.2 断路器原理与实现 256
5.2.3 超时与重试 260
5.3 高并发 262
5.3.1 异步 263
5.3.2 缓存 270
5.4 总结 272
第6章 微服务下如何保证事务的一致性 273
6.1 从本地事务到分布式事务的演变 273
6.2 强一致性解决方案 276
6.2.1 二阶段提交协议 276
6.2.2 三阶段提交协议 278
6.3 最终一致性解决方案 280
6.3.1 TCC模式 280
6.3.2 补偿模式 285
6.3.3 可靠事件模式 286
6.4 开源项目的分布式事务实现解读 288
6.4.1 Apache RocketMQ 288
6.4.2 ServiceComb 289
第7章 百亿流量微服务网关的设计与实现 293
7.1 API网关概述 293
7.1.1 分布式服务架构、微服务架构与 API 网关 293
7.1.2 API网关的定义、职能与关注点 296
7.1.3 API网关的分类与技术分析 298
7.2 开源网关的分析与调研 300
7.2.1 常见的开源网关介绍 300
7.2.2 四大开源网关的对比分析 308
7.2.3 开源网关的技术总结 309
7.3 百亿流量交易系统API网关设计 310
7.3.1 百亿流量交易系统API网关的现状和面临问题 310
7.3.2 业务网关的设计与最佳实践 313
第8章 微服务编排 317
8.1 Netflix Conductor 317
8.2 Netflix Conductor的架构 319
8.3 Conductor的使用案例 320
8.4 Netflix Conductor源码分析 328
8.4.1 Client层源码分析 330
8.4.2 Server端源码分析 337
8.4.3 core端源码分析 344
第9章 微服务数据抽取与统计 356
9.1 案例小故事 356
9.2 数据仓库概述 358
9.2.1 什么是数据仓库 358
9.2.2 数据仓库架构 360
9.2.3 数据仓库建模方法 361
9.2.4 数据抽取、转换和加载 361
9.2.5 数据统计 362
9.3 数据仓库工具Hive 362
9.3.1 安装Hive 364
9.3.2 Hive数据库 366
9.3.3 Hive表 367
9.4 使用Sqoop抽取数据 369
9.4.1 安装Sqoop 370
9.4.2 将MySQL表数据导入Hive表 372
9.5 ETL作业调度 375
第10章 微服务双活体系建设 377
10.1 系统高可用 377
10.2 双活数据中心 379
10.2.1 单机房部署 379
10.2.2 双机房部署 380
10.2.3 基于支付场景的双活体系建设 383
第11章 基于支付场景下的微服务改造与性能优化 399
11.1 支付场景的介绍 399
11.2 支付业务建模和服务划分 400
11.3 支付场景下微服务架构的详解与分析 402
11.3.1 业务架构分析 402
11.3.2 技术平台详解 404
11.4 从代码层面提升微服务架构的性能 407
11.4.1 从代码和设计的角度看 407
11.4.2 从整体架构的角度看 418
11.5 微服务架构中常见的一些故障分析技巧 421
第12章 遗留系统的微服务架构改造 426
12.1 代码分层结构的转变 426
12.2 遗留系统的债券与思考 430
12.3 从单体系统拆分服务的方法论 431
12.4 遗留系统的微服务架构改造 436
12.4.1 从代码重构开始 436
12.4.2 拆分服务需要面向服务进行架构设计 437
12.4.3 改造是一个渐进的过程 437
12.4.4 单元测试是基石 440
12.4.5 面向失败的设计 440
12.4.6 前后端分离 441
12.4.7 共享现有数据库 441
12.4.8 灰度发布的必要性 442
12.4.9 日志聚合与全链路监控 442
第13章 Service Mesh详解 443
13.1 Service Mesh是什么 443
13.2 Service Mesh的背景 443
13.3 Service Mesh介绍 444
13.3.1 Service Mesh架构 444
13.3.2 Service Mesh能做什么 445
13.4 Service Mesh的价值 446
13.5 Service Mesh现状 447
13.6 Service Mesh存在的问题 448
13.7 Istio详解 449
13.7.1 Istio架构 449
13.7.2 数据平面 450
13.7.3 控制平面 455
13.7.4 Isito案例 458
13.8 Service Mesh展望 461
第14章 微服务监控实战 463
14.1 APM原理与应用 464
14.1.1 什么是APM 464
14.1.2 APM监控点 464
14.1.3 APM深入解析 464
14.2 Prometheus监控系统介绍 492
14.2.1 Prometheus的主要特点 493
14.2.2 Prometheus的架构及组件介绍 493
14.2.3 Prometheus的安装 494
14.2.4 使用Prometheus对MySQL进行监控 498
14.2.5 Prometheus的告警机制 501
高可用可伸缩微服务架构